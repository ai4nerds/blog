<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.43">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>different_batching_in_llm_serving – AI4Nerds</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-7fd0fe4245b865325b8ce8dccb604d59.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-d78aecc9c95638c2005d74ac0a593d47.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">AI4Nerds</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../about.html"> 
<span class="menu-text">About Us</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/ai4nerds/blog"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#llm-serving-methods-and-batching-techniques-a-comprehensive-guide" id="toc-llm-serving-methods-and-batching-techniques-a-comprehensive-guide" class="nav-link active" data-scroll-target="#llm-serving-methods-and-batching-techniques-a-comprehensive-guide">LLM Serving Methods and Batching Techniques: A Comprehensive Guide</a>
  <ul class="collapse">
  <li><a href="#table-of-contents" id="toc-table-of-contents" class="nav-link" data-scroll-target="#table-of-contents">Table of Contents</a></li>
  <li><a href="#introduction-to-llm-serving" id="toc-introduction-to-llm-serving" class="nav-link" data-scroll-target="#introduction-to-llm-serving">Introduction to LLM Serving</a></li>
  <li><a href="#why-batching-matters-in-llm-serving" id="toc-why-batching-matters-in-llm-serving" class="nav-link" data-scroll-target="#why-batching-matters-in-llm-serving">Why Batching Matters in LLM Serving</a>
  <ul class="collapse">
  <li><a href="#key-benefits-of-batching" id="toc-key-benefits-of-batching" class="nav-link" data-scroll-target="#key-benefits-of-batching">Key Benefits of Batching:</a></li>
  </ul></li>
  <li><a href="#overview-of-llm-serving-methods" id="toc-overview-of-llm-serving-methods" class="nav-link" data-scroll-target="#overview-of-llm-serving-methods">Overview of LLM Serving Methods</a>
  <ul class="collapse">
  <li><a href="#online-serving" id="toc-online-serving" class="nav-link" data-scroll-target="#online-serving">Online Serving</a></li>
  <li><a href="#offline-serving" id="toc-offline-serving" class="nav-link" data-scroll-target="#offline-serving">Offline Serving</a></li>
  <li><a href="#hybrid-serving" id="toc-hybrid-serving" class="nav-link" data-scroll-target="#hybrid-serving">Hybrid Serving</a></li>
  </ul></li>
  <li><a href="#batching-techniques-in-llm-serving" id="toc-batching-techniques-in-llm-serving" class="nav-link" data-scroll-target="#batching-techniques-in-llm-serving">Batching Techniques in LLM Serving</a>
  <ul class="collapse">
  <li><a href="#static-batching" id="toc-static-batching" class="nav-link" data-scroll-target="#static-batching">Static Batching</a></li>
  <li><a href="#dynamic-batching" id="toc-dynamic-batching" class="nav-link" data-scroll-target="#dynamic-batching">Dynamic Batching</a></li>
  <li><a href="#continuous-batching" id="toc-continuous-batching" class="nav-link" data-scroll-target="#continuous-batching">Continuous Batching</a></li>
  <li><a href="#padded-batching" id="toc-padded-batching" class="nav-link" data-scroll-target="#padded-batching">Padded Batching</a></li>
  <li><a href="#speculative-batching" id="toc-speculative-batching" class="nav-link" data-scroll-target="#speculative-batching">Speculative Batching</a></li>
  <li><a href="#chunked-batching" id="toc-chunked-batching" class="nav-link" data-scroll-target="#chunked-batching">Chunked Batching</a></li>
  <li><a href="#disaggregate-batching" id="toc-disaggregate-batching" class="nav-link" data-scroll-target="#disaggregate-batching">Disaggregate Batching</a></li>
  </ul></li>
  <li><a href="#comparison-of-batching-techniques" id="toc-comparison-of-batching-techniques" class="nav-link" data-scroll-target="#comparison-of-batching-techniques">Comparison of Batching Techniques</a>
  <ul class="collapse">
  <li><a href="#performance-metrics" id="toc-performance-metrics" class="nav-link" data-scroll-target="#performance-metrics">Performance Metrics</a></li>
  <li><a href="#use-case-suitability" id="toc-use-case-suitability" class="nav-link" data-scroll-target="#use-case-suitability">Use Case Suitability</a></li>
  <li><a href="#implementation-complexity" id="toc-implementation-complexity" class="nav-link" data-scroll-target="#implementation-complexity">Implementation Complexity</a></li>
  </ul></li>
  <li><a href="#challenges-and-trade-offs-in-batching" id="toc-challenges-and-trade-offs-in-batching" class="nav-link" data-scroll-target="#challenges-and-trade-offs-in-batching">Challenges and Trade-offs in Batching</a></li>
  <li><a href="#best-practices-for-optimizing-llm-serving-with-batching" id="toc-best-practices-for-optimizing-llm-serving-with-batching" class="nav-link" data-scroll-target="#best-practices-for-optimizing-llm-serving-with-batching">Best Practices for Optimizing LLM Serving with Batching</a></li>
  <li><a href="#future-trends-in-llm-serving-and-batching" id="toc-future-trends-in-llm-serving-and-batching" class="nav-link" data-scroll-target="#future-trends-in-llm-serving-and-batching">Future Trends in LLM Serving and Batching</a></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<p>title: “LLM Serving Methods and Batching Techniques: A Comprehensive Guide” description: LLM, Batching author: “Neil Dave” date: “2025-04-20”</p>
<section id="llm-serving-methods-and-batching-techniques-a-comprehensive-guide" class="level1">
<h1>LLM Serving Methods and Batching Techniques: A Comprehensive Guide</h1>
<p>Large Language Models (LLMs) have transformed natural language processing, powering applications from conversational AI to automated content generation. However, serving these models efficiently at scale is a formidable challenge due to their computational demands and resource intensity. A critical optimization technique in LLM serving is <strong>batching</strong>, which groups multiple inference requests to maximize hardware utilization and minimize latency. This blog provides an in-depth exploration of LLM serving methods, major batching techniques—including the newly added <strong>chunked batching</strong> and <strong>disaggregate batching</strong>—and a detailed comparison to guide practitioners in selecting the optimal approach for their use case.</p>
<section id="table-of-contents" class="level2">
<h2 class="anchored" data-anchor-id="table-of-contents">Table of Contents</h2>
<ol type="1">
<li>Introduction to LLM Serving</li>
<li>Why Batching Matters in LLM Serving</li>
<li>Overview of LLM Serving Methods
<ul>
<li>Online Serving</li>
<li>Offline Serving</li>
<li>Hybrid Serving</li>
</ul></li>
<li>Batching Techniques in LLM Serving
<ul>
<li>Static Batching</li>
<li>Dynamic Batching</li>
<li>Continuous Batching</li>
<li>Padded Batching</li>
<li>Speculative Batching</li>
<li>Chunked Batching</li>
<li>Disaggregate Batching</li>
</ul></li>
<li>Comparison of Batching Techniques
<ul>
<li>Performance Metrics</li>
<li>Use Case Suitability</li>
<li>Implementation Complexity</li>
</ul></li>
<li>Challenges and Trade-offs in Batching</li>
<li>Best Practices for Optimizing LLM Serving with Batching</li>
<li>Future Trends in LLM Serving and Batching</li>
<li>Conclusion</li>
</ol>
</section>
<section id="introduction-to-llm-serving" class="level2">
<h2 class="anchored" data-anchor-id="introduction-to-llm-serving">Introduction to LLM Serving</h2>
<p>LLM serving involves deploying and managing large language models to handle inference requests in production environments. This process requires balancing latency, throughput, and resource efficiency while ensuring scalability to accommodate diverse workloads. Unlike traditional machine learning models, LLMs such as GPT-4, LLaMA, or Grok have billions of parameters, necessitating substantial computational resources (e.g., GPUs or TPUs) and advanced optimization strategies.</p>
<p>The primary objective of LLM serving is to deliver fast, accurate responses to user queries, whether for real-time applications like chatbots or batch processing tasks like document summarization. Batching is a cornerstone of efficient LLM serving, enabling the grouping of multiple requests to leverage the parallel processing capabilities of modern hardware. This blog delves into the various batching methods, including the newly incorporated chunked and disaggregate batching, their mechanics, advantages, limitations, and comparative analysis.</p>
</section>
<section id="why-batching-matters-in-llm-serving" class="level2">
<h2 class="anchored" data-anchor-id="why-batching-matters-in-llm-serving">Why Batching Matters in LLM Serving</h2>
<p>Batching aggregates multiple input requests into a single batch for processing by the LLM, capitalizing on the parallel processing strengths of GPUs and TPUs. Without batching, requests would be processed sequentially, leading to underutilized hardware and increased latency due to per-request overhead.</p>
<section id="key-benefits-of-batching" class="level3">
<h3 class="anchored" data-anchor-id="key-benefits-of-batching">Key Benefits of Batching:</h3>
<ul>
<li><strong>Improved Throughput</strong>: Processing multiple requests simultaneously increases the number of queries handled per second.</li>
<li><strong>Reduced Latency</strong>: Amortizing setup costs (e.g., data transfer to GPU) across multiple requests lowers per-request latency.</li>
<li><strong>Resource Efficiency</strong>: Maximizes hardware utilization, reducing idle cycles and energy consumption.</li>
<li><strong>Scalability</strong>: Enables handling high request volumes without linearly increasing hardware costs.</li>
</ul>
<p>However, batching introduces complexities such as managing variable input lengths, meeting real-time constraints, and avoiding memory bottlenecks. The choice of batching method significantly impacts performance, necessitating a thorough understanding of available techniques.</p>
</section>
</section>
<section id="overview-of-llm-serving-methods" class="level2">
<h2 class="anchored" data-anchor-id="overview-of-llm-serving-methods">Overview of LLM Serving Methods</h2>
<p>Before exploring batching techniques, let’s outline the primary LLM serving methods, as batching strategies often align with the serving context.</p>
<section id="online-serving" class="level3">
<h3 class="anchored" data-anchor-id="online-serving">Online Serving</h3>
<p>Online serving processes real-time inference requests, such as those from chatbots or interactive applications. It prioritizes low latency and responsiveness, typically using dynamic, continuous, or speculative batching to adapt to fluctuating request rates.</p>
</section>
<section id="offline-serving" class="level3">
<h3 class="anchored" data-anchor-id="offline-serving">Offline Serving</h3>
<p>Offline serving handles large data volumes in non-real-time scenarios, such as generating embeddings or summarizing documents. It emphasizes high throughput and often employs static or padded batching, as latency is less critical.</p>
</section>
<section id="hybrid-serving" class="level3">
<h3 class="anchored" data-anchor-id="hybrid-serving">Hybrid Serving</h3>
<p>Hybrid serving combines online and offline workloads, such as running real-time queries alongside periodic batch jobs. It requires flexible batching strategies to balance latency and throughput, often using a combination of dynamic, continuous, and static batching.</p>
<p>The serving method influences the choice of batching technique, as each has distinct performance requirements.</p>
</section>
</section>
<section id="batching-techniques-in-llm-serving" class="level2">
<h2 class="anchored" data-anchor-id="batching-techniques-in-llm-serving">Batching Techniques in LLM Serving</h2>
<p>This section details the major batching techniques used in LLM serving, including the newly added chunked and disaggregate batching methods, covering their mechanics, advantages, and limitations.</p>
<section id="static-batching" class="level3">
<h3 class="anchored" data-anchor-id="static-batching">Static Batching</h3>
<p><strong>Overview</strong>: Static batching groups a fixed number of requests into a batch before processing. The batch size is predefined, and the system waits until the batch is full or a timeout occurs before forwarding it to the LLM.</p>
<p><strong>Mechanics</strong>:</p>
<ul>
<li>Requests are queued until the batch reaches the specified size (e.g., 32 requests).</li>
<li>The batch is processed as a single unit, leveraging GPU parallelism.</li>
<li>Common in offline serving or scenarios with predictable request rates.</li>
</ul>
<p><strong>Advantages</strong>:</p>
<ul>
<li><strong>High Throughput</strong>: Fixed batch sizes maximize GPU utilization, ideal for offline tasks.</li>
<li><strong>Simplicity</strong>: Easier to implement and optimize due to consistent batch sizes.</li>
<li><strong>Predictable Resource Usage</strong>: Stable memory and compute requirements.</li>
</ul>
<p><strong>Limitations</strong>:</p>
<ul>
<li><strong>Latency Overhead</strong>: Waiting for a full batch can delay processing, unsuitable for real-time applications.</li>
<li><strong>Inefficiency with Variable Workloads</strong>: Underutilizes resources if request rates are low or sporadic.</li>
<li><strong>Poor Handling of Variable Input Lengths</strong>: Requires padding or truncation, wasting compute on shorter inputs.</li>
</ul>
<p><strong>Use Case</strong>: Offline tasks like dataset preprocessing, where latency is less critical, and request volumes are high and predictable.</p>
</section>
<section id="dynamic-batching" class="level3">
<h3 class="anchored" data-anchor-id="dynamic-batching">Dynamic Batching</h3>
<p><strong>Overview</strong>: Dynamic batching adapts the batch size based on incoming requests and system conditions, such as queue length or hardware capacity. It balances latency and throughput by processing batches as soon as possible.</p>
<p><strong>Mechanics</strong>:</p>
<ul>
<li>Requests are collected in a queue with a maximum batch size and a timeout.</li>
<li>The system processes the batch when either the batch size or timeout is reached.</li>
<li>Often used in online serving to handle variable request rates.</li>
</ul>
<p><strong>Advantages</strong>:</p>
<ul>
<li><strong>Flexibility</strong>: Adapts to fluctuating workloads, reducing latency during low traffic.</li>
<li><strong>Better Latency-Throughput Trade-off</strong>: Processes requests sooner than static batching in real-time scenarios.</li>
<li><strong>Efficient Resource Use</strong>: Avoids waiting for a full batch during low request volumes.</li>
</ul>
<p><strong>Limitations</strong>:</p>
<ul>
<li><strong>Complexity</strong>: Requires tuning parameters like timeout and maximum batch size.</li>
<li><strong>Variable Performance</strong>: Inconsistent batch sizes can lead to suboptimal GPU utilization.</li>
<li><strong>Overhead</strong>: Dynamic scheduling adds computational overhead compared to static batching.</li>
</ul>
<p><strong>Use Case</strong>: Real-time applications like chatbots or APIs, where request rates vary, and low latency is critical.</p>
</section>
<section id="continuous-batching" class="level3">
<h3 class="anchored" data-anchor-id="continuous-batching">Continuous Batching</h3>
<p><strong>Overview</strong>: Continuous batching, also known as iterative or micro-batching, processes requests incrementally as they arrive, without waiting for a full batch. It pipelines requests to keep the GPU busy, maximizing throughput while minimizing latency.</p>
<p><strong>Mechanics</strong>:</p>
<ul>
<li>Requests are added to an active batch as they arrive, and the batch is processed in small increments.</li>
<li>The system dynamically adjusts the batch composition, evicting completed requests and adding new ones.</li>
<li>Requires sophisticated scheduling to manage variable input lengths and dependencies.</li>
</ul>
<p><strong>Advantages</strong>:</p>
<ul>
<li><strong>Low Latency</strong>: Processes requests as soon as possible, ideal for real-time applications.</li>
<li><strong>High Throughput</strong>: Keeps hardware fully utilized by continuously feeding new requests.</li>
<li><strong>Efficient for Variable Lengths</strong>: Handles diverse input sizes without excessive padding.</li>
</ul>
<p><strong>Limitations</strong>:</p>
<ul>
<li><strong>High Complexity</strong>: Requires advanced scheduling and memory management.</li>
<li><strong>Resource Contention</strong>: Dynamic batch updates can lead to memory fragmentation or contention.</li>
<li><strong>Implementation Cost</strong>: Harder to integrate with existing serving frameworks.</li>
</ul>
<p><strong>Use Case</strong>: High-traffic online serving, such as interactive AI assistants, where both latency and throughput are critical.</p>
</section>
<section id="padded-batching" class="level3">
<h3 class="anchored" data-anchor-id="padded-batching">Padded Batching</h3>
<p><strong>Overview</strong>: Padded batching aligns inputs of varying lengths by adding padding tokens (e.g., zeros) to shorter sequences, ensuring uniform batch dimensions for efficient processing.</p>
<p><strong>Mechanics</strong>:</p>
<ul>
<li>Inputs are padded to match the length of the longest sequence in the batch.</li>
<li>The padded batch is processed as a single unit, with padding tokens ignored during computation.</li>
<li>Often combined with static or dynamic batching.</li>
</ul>
<p><strong>Advantages</strong>:</p>
<ul>
<li><strong>Uniform Processing</strong>: Simplifies matrix operations on GPUs, as all inputs have the same dimensions.</li>
<li><strong>Compatibility</strong>: Works with most LLM architectures and serving frameworks.</li>
<li><strong>Predictable Performance</strong>: Consistent batch shapes improve optimization.</li>
</ul>
<p><strong>Limitations</strong>:</p>
<ul>
<li><strong>Wasted Compute</strong>: Padding tokens consume resources without contributing to the output.</li>
<li><strong>Memory Overhead</strong>: Longer sequences increase memory usage, limiting batch size.</li>
<li><strong>Latency Impact</strong>: Padding can slow down processing, especially for highly variable input lengths.</li>
</ul>
<p><strong>Use Case</strong>: Scenarios with moderate input length variability, such as text classification or translation, where simplicity is prioritized.</p>
</section>
<section id="speculative-batching" class="level3">
<h3 class="anchored" data-anchor-id="speculative-batching">Speculative Batching</h3>
<p><strong>Overview</strong>: Speculative batching leverages speculative execution to predict and process potential future requests, reducing latency for interactive applications. It’s an emerging technique inspired by speculative decoding.</p>
<p><strong>Mechanics</strong>:</p>
<ul>
<li>The system predicts likely user inputs or continuation tokens based on context or historical data.</li>
<li>Predicted requests are batched with actual requests and processed preemptively.</li>
<li>If predictions are correct, results are served instantly; otherwise, they’re discarded.</li>
</ul>
<p><strong>Advantages</strong>:</p>
<ul>
<li><strong>Ultra-Low Latency</strong>: Correct predictions eliminate processing delays for subsequent requests.</li>
<li><strong>Improved User Experience</strong>: Enhances responsiveness in interactive applications.</li>
<li><strong>Resource Optimization</strong>: Combines speculative and actual requests to maximize GPU utilization.</li>
</ul>
<p><strong>Limitations</strong>:</p>
<ul>
<li><strong>Prediction Accuracy</strong>: Incorrect predictions waste compute resources.</li>
<li><strong>High Complexity</strong>: Requires sophisticated prediction models and integration with serving pipelines.</li>
<li><strong>Limited Applicability</strong>: Best suited for predictable workloads, such as conversational AI.</li>
</ul>
<p><strong>Use Case</strong>: Interactive applications with predictable user behavior, such as autocomplete systems or conversational agents.</p>
</section>
<section id="chunked-batching" class="level3">
<h3 class="anchored" data-anchor-id="chunked-batching">Chunked Batching</h3>
<p><strong>Overview</strong>: Chunked batching breaks down long input sequences or large batches into smaller, manageable chunks that are processed sequentially or in parallel. This approach is particularly useful for handling very long inputs or memory-constrained environments.</p>
<p><strong>Mechanics</strong>:</p>
<ul>
<li>Long input sequences are split into fixed-size chunks (e.g., 512 tokens each).</li>
<li>Chunks are batched together, either within the same request or across multiple requests, and processed independently or with dependency tracking.</li>
<li>The system reassembles chunk outputs to produce the final result, often using techniques like key-value caching to maintain context across chunks.</li>
</ul>
<p><strong>Advantages</strong>:</p>
<ul>
<li><strong>Memory Efficiency</strong>: Reduces memory requirements by processing smaller chunks, enabling larger effective batch sizes.</li>
<li><strong>Scalability</strong>: Handles very long sequences (e.g., document summarization) without exceeding hardware limits.</li>
<li><strong>Parallelization</strong>: Chunks can be processed in parallel across multiple devices, improving throughput.</li>
</ul>
<p><strong>Limitations</strong>:</p>
<ul>
<li><strong>Overhead</strong>: Chunking and reassembly introduce computational and scheduling overhead.</li>
<li><strong>Dependency Management</strong>: Maintaining context across chunks (e.g., in autoregressive models) requires careful caching and synchronization.</li>
<li><strong>Latency Increase</strong>: Sequential chunk processing can increase latency for single requests, though parallelization mitigates this.</li>
</ul>
<p><strong>Use Case</strong>: Applications with long input sequences, such as document processing, code generation, or summarization, where memory constraints are a concern.</p>
</section>
<section id="disaggregate-batching" class="level3">
<h3 class="anchored" data-anchor-id="disaggregate-batching">Disaggregate Batching</h3>
<p><strong>Overview</strong>: Disaggregate batching decouples the processing of different components of a batch, such as attention layers, feed-forward networks, or token generation steps, to optimize resource allocation and improve throughput. It is particularly effective in distributed or heterogeneous hardware setups.</p>
<p><strong>Mechanics</strong>:</p>
<ul>
<li>The LLM’s computation graph is split into stages (e.g., attention, feed-forward, or decoding steps).</li>
<li>Each stage is processed independently, with batches tailored to the specific computational requirements of that stage.</li>
<li>Requests are dynamically routed across hardware resources (e.g., GPUs, TPUs, or CPUs) based on stage-specific demands, often using pipeline parallelism.</li>
</ul>
<p><strong>Advantages</strong>:</p>
<ul>
<li><strong>Resource Optimization</strong>: Allocates compute resources efficiently by matching batch sizes to stage-specific needs.</li>
<li><strong>High Throughput</strong>: Enables parallel processing of different stages, reducing idle time in distributed systems.</li>
<li><strong>Flexibility</strong>: Adapts to heterogeneous hardware, leveraging specialized accelerators for specific tasks.</li>
</ul>
<p><strong>Limitations</strong>:</p>
<ul>
<li><strong>High Complexity</strong>: Requires sophisticated orchestration to manage stage transitions and data movement.</li>
<li><strong>Latency Overhead</strong>: Inter-stage communication and synchronization can increase latency, especially in real-time scenarios.</li>
<li><strong>Implementation Cost</strong>: Demands advanced frameworks (e.g., DeepSpeed, Megatron-LM) and expertise in distributed systems.</li>
</ul>
<p><strong>Use Case</strong>: Large-scale distributed serving environments, such as cloud-based LLM inference platforms, where maximizing throughput across heterogeneous hardware is critical.</p>
</section>
</section>
<section id="comparison-of-batching-techniques" class="level2">
<h2 class="anchored" data-anchor-id="comparison-of-batching-techniques">Comparison of Batching Techniques</h2>
<p>To select the optimal batching method, we compare them across key dimensions: performance metrics, use case suitability, and implementation complexity.</p>
<section id="performance-metrics" class="level3">
<h3 class="anchored" data-anchor-id="performance-metrics">Performance Metrics</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
</colgroup>
<thead>
<tr class="header">
<th><strong>Batching Method</strong></th>
<th><strong>Latency</strong></th>
<th><strong>Throughput</strong></th>
<th><strong>Resource Utilization</strong></th>
<th><strong>Scalability</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Static Batching</strong></td>
<td>High (due to waiting)</td>
<td>Very High</td>
<td>High</td>
<td>High (predictable)</td>
</tr>
<tr class="even">
<td><strong>Dynamic Batching</strong></td>
<td>Moderate</td>
<td>High</td>
<td>Moderate</td>
<td>High (adaptive)</td>
</tr>
<tr class="odd">
<td><strong>Continuous Batching</strong></td>
<td>Low</td>
<td>Very High</td>
<td>Very High</td>
<td>High (dynamic)</td>
</tr>
<tr class="even">
<td><strong>Padded Batching</strong></td>
<td>Moderate-High</td>
<td>Moderate</td>
<td>Moderate</td>
<td>Moderate</td>
</tr>
<tr class="odd">
<td><strong>Speculative Batching</strong></td>
<td>Very Low (if accurate)</td>
<td>High</td>
<td>High (if accurate)</td>
<td>Moderate</td>
</tr>
<tr class="even">
<td><strong>Chunked Batching</strong></td>
<td>Moderate-High</td>
<td>High</td>
<td>High</td>
<td>High (memory-bound)</td>
</tr>
<tr class="odd">
<td><strong>Disaggregate Batching</strong></td>
<td>Moderate (stage-dependent)</td>
<td>Very High</td>
<td>Very High</td>
<td>Very High (distributed)</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>Static Batching</strong> excels in throughput for offline tasks but sacrifices latency.</li>
<li><strong>Dynamic Batching</strong> balances latency and throughput, making it versatile for online serving.</li>
<li><strong>Continuous Batching</strong> offers low latency and high throughput but requires advanced infrastructure.</li>
<li><strong>Padded Batching</strong> is resource-intensive due to padding overhead.</li>
<li><strong>Speculative Batching</strong> achieves ultra-low latency but depends on prediction accuracy.</li>
<li><strong>Chunked Batching</strong> improves memory efficiency and scalability for long inputs but may increase latency.</li>
<li><strong>Disaggregate Batching</strong> maximizes throughput in distributed systems but introduces latency due to stage synchronization.</li>
</ul>
</section>
<section id="use-case-suitability" class="level3">
<h3 class="anchored" data-anchor-id="use-case-suitability">Use Case Suitability</h3>
<table class="caption-top table">
<thead>
<tr class="header">
<th><strong>Use Case</strong></th>
<th><strong>Recommended Batching Method</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Offline Data Processing</td>
<td>Static, Padded, Chunked</td>
</tr>
<tr class="even">
<td>Real-Time Chatbots</td>
<td>Dynamic, Continuous, Speculative</td>
</tr>
<tr class="odd">
<td>Interactive AI Assistants</td>
<td>Continuous, Speculative</td>
</tr>
<tr class="even">
<td>Text Classification</td>
<td>Static, Padded</td>
</tr>
<tr class="odd">
<td>Autocomplete Systems</td>
<td>Speculative, Dynamic</td>
</tr>
<tr class="even">
<td>Long Document Processing</td>
<td>Chunked, Continuous</td>
</tr>
<tr class="odd">
<td>Distributed Cloud Inference</td>
<td>Disaggregate, Continuous</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>Offline tasks</strong> benefit from static, padded, or chunked batching due to high throughput needs.</li>
<li><strong>Real-time applications</strong> favor dynamic, continuous, or speculative batching for low latency.</li>
<li><strong>Long sequence processing</strong> is best handled by chunked batching.</li>
<li><strong>Distributed systems</strong> leverage disaggregate batching for resource optimization.</li>
</ul>
</section>
<section id="implementation-complexity" class="level3">
<h3 class="anchored" data-anchor-id="implementation-complexity">Implementation Complexity</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th><strong>Batching Method</strong></th>
<th><strong>Complexity</strong></th>
<th><strong>Key Challenges</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Static Batching</strong></td>
<td>Low</td>
<td>Managing timeouts, handling variable lengths</td>
</tr>
<tr class="even">
<td><strong>Dynamic Batching</strong></td>
<td>Moderate</td>
<td>Tuning batch size and timeout parameters</td>
</tr>
<tr class="odd">
<td><strong>Continuous Batching</strong></td>
<td>High</td>
<td>Scheduling, memory management</td>
</tr>
<tr class="even">
<td><strong>Padded Batching</strong></td>
<td>Low-Moderate</td>
<td>Optimizing padding to minimize waste</td>
</tr>
<tr class="odd">
<td><strong>Speculative Batching</strong></td>
<td>Very High</td>
<td>Prediction model integration, accuracy tuning</td>
</tr>
<tr class="even">
<td><strong>Chunked Batching</strong></td>
<td>Moderate-High</td>
<td>Chunking logic, context management, reassembly</td>
</tr>
<tr class="odd">
<td><strong>Disaggregate Batching</strong></td>
<td>Very High</td>
<td>Stage orchestration, distributed synchronization</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>Static and Padded Batching</strong> are straightforward but less flexible.</li>
<li><strong>Dynamic Batching</strong> requires parameter tuning but is manageable.</li>
<li><strong>Continuous Batching</strong> demands sophisticated scheduling.</li>
<li><strong>Speculative Batching</strong> is complex due to prediction and integration challenges.</li>
<li><strong>Chunked Batching</strong> involves moderate complexity for chunk management and reassembly.</li>
<li><strong>Disaggregate Batching</strong> is the most complex, requiring expertise in distributed systems.</li>
</ul>
</section>
</section>
<section id="challenges-and-trade-offs-in-batching" class="level2">
<h2 class="anchored" data-anchor-id="challenges-and-trade-offs-in-batching">Challenges and Trade-offs in Batching</h2>
<p>Batching enhances efficiency but introduces several challenges:</p>
<ol type="1">
<li><strong>Variable Input Lengths</strong>: LLMs process sequences of varying lengths, complicating batch construction. Padded batching wastes compute, while continuous and chunked batching require dynamic memory management.</li>
<li><strong>Latency-Throughput Trade-off</strong>: Larger batches increase throughput but delay processing. Dynamic, continuous, and speculative batching mitigate this but add complexity.</li>
<li><strong>Memory Constraints</strong>: Large batches or long sequences can exceed GPU memory. Chunked batching addresses this but introduces overhead.</li>
<li><strong>Scheduling Overhead</strong>: Dynamic, continuous, and disaggregate batching require real-time scheduling, which can introduce latency if not optimized.</li>
<li><strong>Prediction Risks in Speculative Batching</strong>: Incorrect predictions waste resources, necessitating high-accuracy models.</li>
<li><strong>Dependency Management in Chunked Batching</strong>: Maintaining context across chunks requires careful caching and synchronization.</li>
<li><strong>Distributed Synchronization in Disaggregate Batching</strong>: Inter-stage communication in distributed systems can lead to latency and complexity.</li>
</ol>
<p>Balancing these trade-offs requires aligning the batching method with the application’s priorities and hardware capabilities.</p>
</section>
<section id="best-practices-for-optimizing-llm-serving-with-batching" class="level2">
<h2 class="anchored" data-anchor-id="best-practices-for-optimizing-llm-serving-with-batching">Best Practices for Optimizing LLM Serving with Batching</h2>
<p>To maximize batching benefits, consider these best practices:</p>
<ol type="1">
<li><strong>Profile Workloads</strong>: Analyze request patterns (e.g., rate, input length distribution) to select the appropriate batching method. Use static or chunked batching for offline tasks and continuous or disaggregate batching for dynamic workloads.</li>
<li><strong>Tune Batch Parameters</strong>: Experiment with batch size, timeout, chunk size, and padding strategies to balance latency and throughput. Monitor performance metrics to guide tuning.</li>
<li><strong>Leverage Hardware Accelerators</strong>: Optimize batch processing for GPUs/TPUs by aligning batch sizes with hardware capabilities. Use disaggregate batching for heterogeneous setups.</li>
<li><strong>Minimize Padding Overhead</strong>: Sort inputs by length, use bucketing, or adopt chunked batching to reduce padding in padded batching.</li>
<li><strong>Implement Robust Scheduling</strong>: For dynamic, continuous, and disaggregate batching, use efficient schedulers (e.g., NVIDIA Triton, vLLM) to manage request queues and avoid contention.</li>
<li><strong>Optimize Chunked Batching</strong>: Use key-value caching to maintain context across chunks and parallelize chunk processing where possible.</li>
<li><strong>Monitor and Scale</strong>: Track system metrics (e.g., GPU utilization, queue length) and scale resources (e.g., add GPUs or nodes) to handle peak loads.</li>
<li><strong>Experiment with Speculative Batching</strong>: Test speculative batching with lightweight prediction models for interactive applications to assess latency benefits.</li>
</ol>
</section>
<section id="future-trends-in-llm-serving-and-batching" class="level2">
<h2 class="anchored" data-anchor-id="future-trends-in-llm-serving-and-batching">Future Trends in LLM Serving and Batching</h2>
<p>The field of LLM serving is evolving rapidly, with trends shaping batching techniques:</p>
<ol type="1">
<li><strong>Advanced Continuous Batching</strong>: Frameworks like vLLM and Hugging Face’s Text Generation Inference are enhancing continuous batching with better scheduling and memory management.</li>
<li><strong>Speculative Decoding Integration</strong>: Speculative batching will integrate with speculative decoding, generating multiple token candidates in parallel to reduce latency.</li>
<li><strong>Hardware-Aware Batching</strong>: Batching methods will optimize for heterogeneous hardware, dynamically adjusting batch sizes and leveraging disaggregate batching.</li>
<li><strong>Federated Serving</strong>: Batching will adapt to distributed edge-cloud systems, balancing local and remote processing.</li>
<li><strong>Energy-Efficient Batching</strong>: Techniques will prioritize energy efficiency, minimizing idle cycles and optimizing resource allocation.</li>
<li><strong>Chunked Batching Enhancements</strong>: Improved caching and parallelization will make chunked batching more efficient for long-sequence tasks.</li>
<li><strong>Disaggregate Batching Adoption</strong>: As distributed systems grow, disaggregate batching will become standard for large-scale inference platforms.</li>
</ol>
<p>These trends underscore the need for flexible, adaptive batching strategies to meet future LLM demands.</p>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>Efficient LLM serving is essential for deploying large language models in production, and batching is a critical component of this process. By understanding the spectrum of batching techniques—static, dynamic, continuous, padded, speculative, chunked, and disaggregate—practitioners can optimize for their specific use case, whether it’s low-latency interactive systems, high-throughput offline processing, or distributed cloud inference. Each method offers unique advantages and trade-offs, necessitating careful alignment with application requirements and hardware constraints.</p>
<p>As LLMs scale and serving frameworks evolve, batching techniques will continue to advance, delivering greater efficiency and responsiveness. By adopting best practices and staying informed about emerging trends, developers can build robust, scalable LLM serving systems that power the next generation of AI-driven applications.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/ai4nerds\.github\.io\/blog");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>