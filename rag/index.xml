<?xml version="1.0" encoding="UTF-8"?>
<rss  xmlns:atom="http://www.w3.org/2005/Atom" 
      xmlns:media="http://search.yahoo.com/mrss/" 
      xmlns:content="http://purl.org/rss/1.0/modules/content/" 
      xmlns:dc="http://purl.org/dc/elements/1.1/" 
      version="2.0">
<channel>
<title>AI4Nerds</title>
<link>https://ai4nerds.github.io/blog/rag/</link>
<atom:link href="https://ai4nerds.github.io/blog/rag/index.xml" rel="self" type="application/rss+xml"/>
<description></description>
<generator>quarto-1.6.43</generator>
<lastBuildDate>Sat, 05 Apr 2025 00:00:00 GMT</lastBuildDate>
<item>
  <title>Mastering Chunking Techniques in RAG for Optimal Performance</title>
  <dc:creator>Neil Dave</dc:creator>
  <link>https://ai4nerds.github.io/blog/rag/Different types of Chunking.html</link>
  <description><![CDATA[ 




<section id="mastering-chunking-techniques-in-rag-for-optimal-performance-and-outreach" class="level1">
<h1>Mastering Chunking Techniques in RAG for Optimal Performance and Outreach</h1>
<p><em>Published on April 05, 2025</em></p>
<p>Retrieval-Augmented Generation (RAG) is revolutionizing how AI systems process and respond to queries by combining retrieval mechanisms with generative models. At the heart of an effective RAG system lies chunking—the process of breaking down large documents into smaller, retrievable units. The way you chunk your data determines retrieval accuracy, computational efficiency, and ultimately, the system’s ability to engage a wide audience. Poor chunking can fragment context, overload resources, or miss critical information, while optimized chunking enhances relevance, speed, and scalability.</p>
<p>In this comprehensive guide, we’ll explore a wide range of chunking techniques—from basic to advanced, including recursive methods—complete with Python implementations. We’ll also discuss how to optimize these techniques for maximum outreach, whether you’re building a chatbot, knowledge base, or content recommendation engine. Let’s dive in!</p>
<section id="table-of-contents" class="level2">
<h2 class="anchored" data-anchor-id="table-of-contents">Table of Contents</h2>
<ol type="1">
<li>Introduction to Chunking in RAG</li>
<li>The Role of Chunking in Outreach</li>
<li>Chunking Techniques
<ul>
<li>Fixed-Size Chunking</li>
<li>Sentence-Based Chunking</li>
<li>Paragraph-Based Chunking</li>
<li>Semantic Chunking</li>
<li>Sliding Window Chunking</li>
<li>Recursive Chunking</li>
<li>Token-Based Chunking</li>
<li>Hierarchical Chunking</li>
<li>Content-Aware Chunking</li>
<li>Hybrid Chunking</li>
</ul></li>
<li>Optimizing Chunking for Performance and Outreach</li>
<li>Comparing Chunking Techniques</li>
<li>Advanced Chunking Techniques</li>
<li>Conclusion</li>
</ol>
</section>
<section id="introduction-to-chunking-in-rag" class="level2">
<h2 class="anchored" data-anchor-id="introduction-to-chunking-in-rag">Introduction to Chunking in RAG</h2>
<p>RAG systems operate in two stages: retrieval and generation. The retriever fetches relevant snippets from a pre-indexed dataset, and the generator crafts responses based on those snippets. Chunking is the preprocessing step that determines how the dataset is segmented into these snippets. Effective chunking ensures that retrieved content is contextually rich, computationally manageable, and aligned with user queries.</p>
<p>Without proper chunking, a RAG system might retrieve incomplete sentences, overload the generator with irrelevant data, or fail to scale across large datasets. This blog explores a spectrum of chunking strategies, each tailored to different types of content and use cases, with practical Python examples to implement them.</p>
</section>
<section id="the-role-of-chunking-in-outreach" class="level2">
<h2 class="anchored" data-anchor-id="the-role-of-chunking-in-outreach">The Role of Chunking in Outreach</h2>
<p>Outreach in RAG systems is about delivering precise, timely, and engaging responses to a broad audience. Chunking influences outreach in several ways: - <strong>Accuracy</strong>: Well-chunked data ensures retrieved snippets fully address user queries. - <strong>Speed</strong>: Smaller, optimized chunks reduce retrieval and processing time. - <strong>Scalability</strong>: Consistent chunking enables the system to handle growing datasets and user bases. - <strong>Engagement</strong>: Relevant, concise answers improve user satisfaction, encouraging repeat interactions.</p>
<p>By mastering chunking, you can enhance your RAG system’s ability to serve diverse audiences effectively.</p>
</section>
<section id="chunking-techniques" class="level2">
<h2 class="anchored" data-anchor-id="chunking-techniques">Chunking Techniques</h2>
<section id="fixed-size-chunking" class="level3">
<h3 class="anchored" data-anchor-id="fixed-size-chunking">Fixed-Size Chunking</h3>
<p><strong>Overview</strong>: Fixed-size chunking divides text into equal-sized segments (e.g., 500 characters or 100 words). It’s straightforward and widely used for its simplicity.</p>
<p><strong>Pros</strong>: - Predictable chunk sizes. - Fast and lightweight.</p>
<p><strong>Cons</strong>: - Ignores semantic boundaries. - May split critical context.</p>
<p><strong>Python Code Snippet</strong>:</p>
<div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> fixed_size_chunking(text, chunk_size<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">500</span>):</span>
<span id="cb1-2">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> [text[i:i <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> chunk_size] <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> i <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>, <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(text), chunk_size)]</span>
<span id="cb1-3"></span>
<span id="cb1-4"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Example</span></span>
<span id="cb1-5">text <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Retrieval-Augmented Generation (RAG) combines retrieval and generation for better AI performance."</span></span>
<span id="cb1-6">chunks <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> fixed_size_chunking(text, chunk_size<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">20</span>)</span>
<span id="cb1-7"><span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> i, chunk <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">enumerate</span>(chunks):</span>
<span id="cb1-8">    <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"Chunk </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">: </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>chunk<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">"</span>)</span></code></pre></div>
<p><strong>Output</strong>:</p>
<pre><code>Chunk 1: Retrieval-Augmented 
Chunk 2: Generation (RAG) com
Chunk 3: bines retrieval and 
Chunk 4: generation for bette
Chunk 5: r AI performance.</code></pre>
<p><strong>Use Case</strong>: Ideal for structured data like logs or when semantic splits are less critical.</p>
</section>
<section id="sentence-based-chunking" class="level3">
<h3 class="anchored" data-anchor-id="sentence-based-chunking">Sentence-Based Chunking</h3>
<p><strong>Overview</strong>: This method splits text into individual sentences using natural language processing (NLP) tools, preserving complete thoughts.</p>
<p><strong>Pros</strong>: - Maintains semantic integrity. - Simple to implement with NLP libraries.</p>
<p><strong>Cons</strong>: - Variable chunk sizes. - Limited context across sentences.</p>
<p><strong>Python Code Snippet</strong>:</p>
<div class="sourceCode" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> nltk</span>
<span id="cb3-2">nltk.download(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'punkt'</span>)</span>
<span id="cb3-3"></span>
<span id="cb3-4"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> sentence_chunking(text):</span>
<span id="cb3-5">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> nltk.sent_tokenize(text)</span>
<span id="cb3-6"></span>
<span id="cb3-7"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Example</span></span>
<span id="cb3-8">text <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"RAG is powerful. It retrieves data efficiently. Chunking is key."</span></span>
<span id="cb3-9">chunks <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> sentence_chunking(text)</span>
<span id="cb3-10"><span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> i, chunk <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">enumerate</span>(chunks):</span>
<span id="cb3-11">    <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"Chunk </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">: </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>chunk<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">"</span>)</span></code></pre></div>
<p><strong>Output</strong>:</p>
<pre><code>Chunk 1: RAG is powerful.
Chunk 2: It retrieves data efficiently.
Chunk 3: Chunking is key.</code></pre>
<p><strong>Use Case</strong>: Best for conversational AI or FAQs requiring concise, standalone answers.</p>
</section>
<section id="paragraph-based-chunking" class="level3">
<h3 class="anchored" data-anchor-id="paragraph-based-chunking">Paragraph-Based Chunking</h3>
<p><strong>Overview</strong>: Paragraph-based chunking splits text at paragraph boundaries, capturing larger units of meaning.</p>
<p><strong>Pros</strong>: - Preserves broader context. - Aligns with document structure.</p>
<p><strong>Cons</strong>: - Inconsistent chunk sizes. - May include irrelevant details.</p>
<p><strong>Python Code Snippet</strong>:</p>
<div class="sourceCode" id="cb5" style="background: #f1f3f5;"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> paragraph_chunking(text):</span>
<span id="cb5-2">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> [chunk.strip() <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> chunk <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> text.split(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'</span><span class="ch" style="color: #20794D;
background-color: null;
font-style: inherit;">\n\n</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'</span>) <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> chunk.strip()]</span>
<span id="cb5-3"></span>
<span id="cb5-4"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Example</span></span>
<span id="cb5-5">text <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"RAG combines retrieval and generation.</span><span class="ch" style="color: #20794D;
background-color: null;
font-style: inherit;">\n\n</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">It improves AI responses.</span><span class="ch" style="color: #20794D;
background-color: null;
font-style: inherit;">\n\n</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">Chunking optimizes this."</span></span>
<span id="cb5-6">chunks <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> paragraph_chunking(text)</span>
<span id="cb5-7"><span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> i, chunk <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">enumerate</span>(chunks):</span>
<span id="cb5-8">    <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"Chunk </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">: </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>chunk<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">"</span>)</span></code></pre></div>
<p><strong>Output</strong>:</p>
<pre><code>Chunk 1: RAG combines retrieval and generation.
Chunk 2: It improves AI responses.
Chunk 3: Chunking optimizes this.</code></pre>
<p><strong>Use Case</strong>: Suited for articles, reports, or blogs with distinct sections.</p>
</section>
<section id="semantic-chunking" class="level3">
<h3 class="anchored" data-anchor-id="semantic-chunking">Semantic Chunking</h3>
<p><strong>Overview</strong>: Semantic chunking uses NLP models to group text based on meaning, often leveraging embeddings to measure similarity.</p>
<p><strong>Pros</strong>: - High retrieval relevance. - Contextually intelligent.</p>
<p><strong>Cons</strong>: - Computationally intensive. - Requires pretrained models.</p>
<p><strong>Python Code Snippet</strong>:</p>
<div class="sourceCode" id="cb7" style="background: #f1f3f5;"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> sentence_transformers <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> SentenceTransformer</span>
<span id="cb7-2"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> numpy <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">as</span> np</span>
<span id="cb7-3"></span>
<span id="cb7-4"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> semantic_chunking(text, threshold<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.7</span>):</span>
<span id="cb7-5">    model <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> SentenceTransformer(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'all-MiniLM-L6-v2'</span>)</span>
<span id="cb7-6">    sentences <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> text.split(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'. '</span>)</span>
<span id="cb7-7">    embeddings <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> model.encode(sentences)</span>
<span id="cb7-8">    </span>
<span id="cb7-9">    chunks <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> []</span>
<span id="cb7-10">    current_chunk <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [sentences[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>]]</span>
<span id="cb7-11">    </span>
<span id="cb7-12">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> i <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>, <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(sentences)):</span>
<span id="cb7-13">        similarity <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> np.dot(embeddings[i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>], embeddings[i]) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/</span> (np.linalg.norm(embeddings[i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>]) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span> np.linalg.norm(embeddings[i]))</span>
<span id="cb7-14">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> similarity <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;</span> threshold:</span>
<span id="cb7-15">            current_chunk.append(sentences[i])</span>
<span id="cb7-16">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">else</span>:</span>
<span id="cb7-17">            chunks.append(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'. '</span>.join(current_chunk))</span>
<span id="cb7-18">            current_chunk <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [sentences[i]]</span>
<span id="cb7-19">    chunks.append(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'. '</span>.join(current_chunk))</span>
<span id="cb7-20">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> chunks</span>
<span id="cb7-21"></span>
<span id="cb7-22"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Example</span></span>
<span id="cb7-23">text <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"RAG is great. It retrieves data. Generation is separate. Chunking matters."</span></span>
<span id="cb7-24">chunks <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> semantic_chunking(text)</span>
<span id="cb7-25"><span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> i, chunk <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">enumerate</span>(chunks):</span>
<span id="cb7-26">    <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"Chunk </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">: </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>chunk<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">"</span>)</span></code></pre></div>
<p><strong>Output</strong> (varies):</p>
<pre><code>Chunk 1: RAG is great. It retrieves data
Chunk 2: Generation is separate. Chunking matters</code></pre>
<p><strong>Use Case</strong>: Ideal for research papers or complex texts requiring deep context.</p>
</section>
<section id="sliding-window-chunking" class="level3">
<h3 class="anchored" data-anchor-id="sliding-window-chunking">Sliding Window Chunking</h3>
<p><strong>Overview</strong>: This method uses a fixed-size window that slides over the text with an overlap, ensuring continuity between chunks.</p>
<p><strong>Pros</strong>: - Maintains context across chunks. - Adjustable overlap.</p>
<p><strong>Cons</strong>: - Redundant data. - Higher storage needs.</p>
<p><strong>Python Code Snippet</strong>:</p>
<div class="sourceCode" id="cb9" style="background: #f1f3f5;"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> sliding_window_chunking(text, window_size<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">100</span>, overlap<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">20</span>):</span>
<span id="cb9-2">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> [text[i:i <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> window_size] <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> i <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>, <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(text) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span> window_size <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>, window_size <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span> overlap)]</span>
<span id="cb9-3"></span>
<span id="cb9-4"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Example</span></span>
<span id="cb9-5">text <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"RAG systems improve AI by combining retrieval and generation effectively."</span></span>
<span id="cb9-6">chunks <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> sliding_window_chunking(text, window_size<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">20</span>, overlap<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">5</span>)</span>
<span id="cb9-7"><span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> i, chunk <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">enumerate</span>(chunks):</span>
<span id="cb9-8">    <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"Chunk </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">: </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>chunk<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">"</span>)</span></code></pre></div>
<p><strong>Output</strong>:</p>
<pre><code>Chunk 1: RAG systems improve 
Chunk 2: improve AI by combi
Chunk 3: by combining retriev
Chunk 4: retrieval and genera
Chunk 5: generation effective
Chunk 6: effectively.</code></pre>
<p><strong>Use Case</strong>: Great for streaming data or when context continuity is vital.</p>
</section>
<section id="recursive-chunking" class="level3">
<h3 class="anchored" data-anchor-id="recursive-chunking">Recursive Chunking</h3>
<p><strong>Overview</strong>: Recursive chunking splits text hierarchically, first into large segments (e.g., paragraphs), then into smaller units (e.g., sentences) if needed, based on size or content constraints.</p>
<p><strong>Pros</strong>: - Flexible and adaptive. - Balances granularity and context.</p>
<p><strong>Cons</strong>: - Complex to implement. - May over-segment.</p>
<p><strong>Python Code Snippet</strong>:</p>
<div class="sourceCode" id="cb11" style="background: #f1f3f5;"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> recursive_chunking(text, max_size<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">200</span>):</span>
<span id="cb11-2">    <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> split_recursive(segment):</span>
<span id="cb11-3">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(segment) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;=</span> max_size:</span>
<span id="cb11-4">            <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> [segment]</span>
<span id="cb11-5">        paragraphs <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> segment.split(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'</span><span class="ch" style="color: #20794D;
background-color: null;
font-style: inherit;">\n\n</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'</span>)</span>
<span id="cb11-6">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(paragraphs) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>:</span>
<span id="cb11-7">            result <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> []</span>
<span id="cb11-8">            <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> p <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> paragraphs:</span>
<span id="cb11-9">                result.extend(split_recursive(p))</span>
<span id="cb11-10">            <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> result</span>
<span id="cb11-11">        sentences <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> nltk.sent_tokenize(segment)</span>
<span id="cb11-12">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> sentences <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(sentences) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span> <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">else</span> [segment]</span>
<span id="cb11-13">    </span>
<span id="cb11-14">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> split_recursive(text)</span>
<span id="cb11-15"></span>
<span id="cb11-16"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Example</span></span>
<span id="cb11-17">text <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"RAG is a hybrid model.</span><span class="ch" style="color: #20794D;
background-color: null;
font-style: inherit;">\n\n</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">It retrieves and generates.</span><span class="ch" style="color: #20794D;
background-color: null;
font-style: inherit;">\n\n</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">Chunking is complex but critical."</span></span>
<span id="cb11-18">chunks <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> recursive_chunking(text, max_size<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">30</span>)</span>
<span id="cb11-19"><span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> i, chunk <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">enumerate</span>(chunks):</span>
<span id="cb11-20">    <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"Chunk </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">: </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>chunk<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">"</span>)</span></code></pre></div>
<p><strong>Output</strong>:</p>
<pre><code>Chunk 1: RAG is a hybrid model.
Chunk 2: It retrieves and generates.
Chunk 3: Chunking is complex but critical.</code></pre>
<p><strong>Use Case</strong>: Useful for large documents with nested structures, like books or manuals.</p>
</section>
<section id="token-based-chunking" class="level3">
<h3 class="anchored" data-anchor-id="token-based-chunking">Token-Based Chunking</h3>
<p><strong>Overview</strong>: Token-based chunking splits text into chunks based on token counts (e.g., words or subwords), often aligned with model tokenization limits.</p>
<p><strong>Pros</strong>: - Compatible with LLMs. - Consistent sizing.</p>
<p><strong>Cons</strong>: - Requires tokenizer. - May split mid-sentence.</p>
<p><strong>Python Code Snippet</strong>:</p>
<div class="sourceCode" id="cb13" style="background: #f1f3f5;"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> transformers <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> AutoTokenizer</span>
<span id="cb13-2"></span>
<span id="cb13-3"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> token_based_chunking(text, max_tokens<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">50</span>):</span>
<span id="cb13-4">    tokenizer <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> AutoTokenizer.from_pretrained(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'bert-base-uncased'</span>)</span>
<span id="cb13-5">    tokens <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> tokenizer.tokenize(text)</span>
<span id="cb13-6">    chunks <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> []</span>
<span id="cb13-7">    current_chunk <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> []</span>
<span id="cb13-8">    current_count <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span></span>
<span id="cb13-9">    </span>
<span id="cb13-10">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> token <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> tokens:</span>
<span id="cb13-11">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> current_count <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;=</span> max_tokens:</span>
<span id="cb13-12">            current_chunk.append(token)</span>
<span id="cb13-13">            current_count <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span></span>
<span id="cb13-14">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">else</span>:</span>
<span id="cb13-15">            chunks.append(tokenizer.convert_tokens_to_string(current_chunk))</span>
<span id="cb13-16">            current_chunk <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [token]</span>
<span id="cb13-17">            current_count <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span></span>
<span id="cb13-18">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> current_chunk:</span>
<span id="cb13-19">        chunks.append(tokenizer.convert_tokens_to_string(current_chunk))</span>
<span id="cb13-20">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> chunks</span>
<span id="cb13-21"></span>
<span id="cb13-22"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Example</span></span>
<span id="cb13-23">text <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"RAG enhances AI by combining retrieval and generation techniques."</span></span>
<span id="cb13-24">chunks <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> token_based_chunking(text, max_tokens<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">10</span>)</span>
<span id="cb13-25"><span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> i, chunk <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">enumerate</span>(chunks):</span>
<span id="cb13-26">    <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"Chunk </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">: </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>chunk<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">"</span>)</span></code></pre></div>
<p><strong>Output</strong> (varies):</p>
<pre><code>Chunk 1: RAG enhances AI by combining retrieval and generation
Chunk 2: techniques.</code></pre>
<p><strong>Use Case</strong>: Best for LLM-integrated RAG systems with token limits.</p>
</section>
<section id="hierarchical-chunking" class="level3">
<h3 class="anchored" data-anchor-id="hierarchical-chunking">Hierarchical Chunking</h3>
<p><strong>Overview</strong>: Hierarchical chunking creates a multi-level structure (e.g., sections, subsections, sentences), enabling retrieval at different granularity levels.</p>
<p><strong>Pros</strong>: - Multi-scale retrieval. - Rich context.</p>
<p><strong>Cons</strong>: - Requires structured input. - Complex indexing.</p>
<p><strong>Python Code Snippet</strong>:</p>
<div class="sourceCode" id="cb15" style="background: #f1f3f5;"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> hierarchical_chunking(text, levels<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>[<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'</span><span class="ch" style="color: #20794D;
background-color: null;
font-style: inherit;">\n\n</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'. '</span>]):</span>
<span id="cb15-2">    hierarchy <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> []</span>
<span id="cb15-3">    current_level <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [text]</span>
<span id="cb15-4">    </span>
<span id="cb15-5">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> delimiter <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> levels:</span>
<span id="cb15-6">        next_level <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> []</span>
<span id="cb15-7">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> chunk <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> current_level:</span>
<span id="cb15-8">            sub_chunks <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> chunk.split(delimiter)</span>
<span id="cb15-9">            next_level.extend([sub.strip() <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> sub <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> sub_chunks <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> sub.strip()])</span>
<span id="cb15-10">        hierarchy.append(next_level)</span>
<span id="cb15-11">        current_level <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> next_level</span>
<span id="cb15-12">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> hierarchy</span>
<span id="cb15-13"></span>
<span id="cb15-14"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Example</span></span>
<span id="cb15-15">text <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"RAG is great.</span><span class="ch" style="color: #20794D;
background-color: null;
font-style: inherit;">\n\n</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">It retrieves data. Generation follows."</span></span>
<span id="cb15-16">chunks <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> hierarchical_chunking(text)</span>
<span id="cb15-17"><span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> level, chunks_at_level <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">enumerate</span>(chunks):</span>
<span id="cb15-18">    <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"Level </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>level<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">:"</span>)</span>
<span id="cb15-19">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> i, chunk <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">enumerate</span>(chunks_at_level):</span>
<span id="cb15-20">        <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"  Chunk </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">: </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>chunk<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">"</span>)</span></code></pre></div>
<p><strong>Output</strong>:</p>
<pre><code>Level 0:
  Chunk 1: RAG is great.
  Chunk 2: It retrieves data. Generation follows.
Level 1:
  Chunk 1: RAG is great
  Chunk 2: It retrieves data
  Chunk 3: Generation follows</code></pre>
<p><strong>Use Case</strong>: Ideal for structured documents like textbooks or technical manuals.</p>
</section>
<section id="content-aware-chunking" class="level3">
<h3 class="anchored" data-anchor-id="content-aware-chunking">Content-Aware Chunking</h3>
<p><strong>Overview</strong>: This method uses metadata or content cues (e.g., headings, keywords) to guide chunking, aligning splits with document intent.</p>
<p><strong>Pros</strong>: - Highly relevant chunks. - Context-sensitive.</p>
<p><strong>Cons</strong>: - Needs metadata or preprocessing. - Domain-specific.</p>
<p><strong>Python Code Snippet</strong>:</p>
<div class="sourceCode" id="cb17" style="background: #f1f3f5;"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb17-1"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> content_aware_chunking(text, keywords<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>[<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'RAG'</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'Chunking'</span>]):</span>
<span id="cb17-2">    chunks <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> []</span>
<span id="cb17-3">    current_chunk <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> []</span>
<span id="cb17-4">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> line <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> text.split(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'</span><span class="ch" style="color: #20794D;
background-color: null;
font-style: inherit;">\n</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'</span>):</span>
<span id="cb17-5">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">any</span>(kw <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> line <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> kw <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> keywords) <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">and</span> current_chunk:</span>
<span id="cb17-6">            chunks.append(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'</span><span class="ch" style="color: #20794D;
background-color: null;
font-style: inherit;">\n</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'</span>.join(current_chunk))</span>
<span id="cb17-7">            current_chunk <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [line]</span>
<span id="cb17-8">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">else</span>:</span>
<span id="cb17-9">            current_chunk.append(line)</span>
<span id="cb17-10">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> current_chunk:</span>
<span id="cb17-11">        chunks.append(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'</span><span class="ch" style="color: #20794D;
background-color: null;
font-style: inherit;">\n</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'</span>.join(current_chunk))</span>
<span id="cb17-12">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> chunks</span>
<span id="cb17-13"></span>
<span id="cb17-14"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Example</span></span>
<span id="cb17-15">text <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Intro to AI.</span><span class="ch" style="color: #20794D;
background-color: null;
font-style: inherit;">\n</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">RAG is powerful.</span><span class="ch" style="color: #20794D;
background-color: null;
font-style: inherit;">\n</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">Details here.</span><span class="ch" style="color: #20794D;
background-color: null;
font-style: inherit;">\n</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">Chunking matters."</span></span>
<span id="cb17-16">chunks <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> content_aware_chunking(text)</span>
<span id="cb17-17"><span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> i, chunk <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">enumerate</span>(chunks):</span>
<span id="cb17-18">    <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"Chunk </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">: </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>chunk<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">"</span>)</span></code></pre></div>
<p><strong>Output</strong>:</p>
<pre><code>Chunk 1: Intro to AI.
Chunk 2: RAG is powerful.
Chunk 3: Details here.
Chunk 4: Chunking matters.</code></pre>
<p><strong>Use Case</strong>: Perfect for web pages or annotated datasets.</p>
</section>
<section id="hybrid-chunking" class="level3">
<h3 class="anchored" data-anchor-id="hybrid-chunking">Hybrid Chunking</h3>
<p><strong>Overview</strong>: Hybrid chunking combines multiple methods (e.g., semantic and token-based) for flexibility and precision.</p>
<p><strong>Pros</strong>: - Balances trade-offs. - Adapts to content.</p>
<p><strong>Cons</strong>: - Complex to tune. - Higher overhead.</p>
<p><strong>Python Code Snippet</strong>:</p>
<div class="sourceCode" id="cb19" style="background: #f1f3f5;"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb19-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> sentence_transformers <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> SentenceTransformer</span>
<span id="cb19-2"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> numpy <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">as</span> np</span>
<span id="cb19-3"></span>
<span id="cb19-4"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> hybrid_chunking(text, max_size<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">200</span>, similarity_threshold<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.7</span>):</span>
<span id="cb19-5">    model <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> SentenceTransformer(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'all-MiniLM-L6-v2'</span>)</span>
<span id="cb19-6">    sentences <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> nltk.sent_tokenize(text)</span>
<span id="cb19-7">    embeddings <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> model.encode(sentences)</span>
<span id="cb19-8">    </span>
<span id="cb19-9">    chunks <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> []</span>
<span id="cb19-10">    current_chunk <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> []</span>
<span id="cb19-11">    current_size <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span></span>
<span id="cb19-12">    </span>
<span id="cb19-13">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> i, sentence <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">enumerate</span>(sentences):</span>
<span id="cb19-14">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> current_size <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(sentence) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;=</span> max_size <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">and</span> (<span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">not</span> current_chunk <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">or</span> </span>
<span id="cb19-15">            np.dot(embeddings[i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>], embeddings[i]) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/</span> (np.linalg.norm(embeddings[i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>]) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span> np.linalg.norm(embeddings[i])) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;</span> similarity_threshold):</span>
<span id="cb19-16">            current_chunk.append(sentence)</span>
<span id="cb19-17">            current_size <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+=</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(sentence)</span>
<span id="cb19-18">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">else</span>:</span>
<span id="cb19-19">            chunks.append(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">' '</span>.join(current_chunk))</span>
<span id="cb19-20">            current_chunk <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [sentence]</span>
<span id="cb19-21">            current_size <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(sentence)</span>
<span id="cb19-22">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> current_chunk:</span>
<span id="cb19-23">        chunks.append(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">' '</span>.join(current_chunk))</span>
<span id="cb19-24">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> chunks</span>
<span id="cb19-25"></span>
<span id="cb19-26"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Example</span></span>
<span id="cb19-27">text <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"RAG is great. It retrieves data. Generation follows. Chunking matters."</span></span>
<span id="cb19-28">chunks <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> hybrid_chunking(text)</span>
<span id="cb19-29"><span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> i, chunk <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">enumerate</span>(chunks):</span>
<span id="cb19-30">    <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"Chunk </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">: </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>chunk<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">"</span>)</span></code></pre></div>
<p><strong>Output</strong> (varies):</p>
<pre><code>Chunk 1: RAG is great. It retrieves data
Chunk 2: Generation follows. Chunking matters</code></pre>
<p><strong>Use Case</strong>: Best for mixed-content datasets like websites or user manuals.</p>
</section>
</section>
<section id="optimizing-chunking-for-performance-and-outreach" class="level2">
<h2 class="anchored" data-anchor-id="optimizing-chunking-for-performance-and-outreach">Optimizing Chunking for Performance and Outreach</h2>
<p>To maximize performance and outreach: 1. <strong>Tune Parameters</strong>: Adjust chunk sizes, overlaps, or thresholds based on domain. 2. <strong>Use Metadata</strong>: Enhance chunks with tags or summaries for better retrieval. 3. <strong>Monitor Metrics</strong>: Track precision, recall, and latency to refine strategies. 4. <strong>Scale Efficiently</strong>: Parallelize chunking for large datasets. 5. <strong>User-Centric Design</strong>: Adapt chunking based on audience needs (e.g., concise for mobile users).</p>
</section>
<section id="comparing-chunking-techniques" class="level2">
<h2 class="anchored" data-anchor-id="comparing-chunking-techniques">Comparing Chunking Techniques</h2>
<table class="caption-top table">
<colgroup>
<col style="width: 20%">
<col style="width: 27%">
<col style="width: 27%">
<col style="width: 24%">
</colgroup>
<thead>
<tr class="header">
<th>Technique</th>
<th>Pros</th>
<th>Cons</th>
<th>Best For</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Fixed-Size</td>
<td>Simple, fast</td>
<td>Ignores semantics</td>
<td>Structured data</td>
</tr>
<tr class="even">
<td>Sentence-Based</td>
<td>Semantic integrity</td>
<td>Variable sizes</td>
<td>Conversational AI</td>
</tr>
<tr class="odd">
<td>Paragraph-Based</td>
<td>Broader context</td>
<td>Inconsistent sizes</td>
<td>Articles, reports</td>
</tr>
<tr class="even">
<td>Semantic</td>
<td>High relevance</td>
<td>Resource-intensive</td>
<td>Complex documents</td>
</tr>
<tr class="odd">
<td>Sliding Window</td>
<td>Continuity</td>
<td>Redundant data</td>
<td>Streaming data</td>
</tr>
<tr class="even">
<td>Recursive</td>
<td>Flexible granularity</td>
<td>Complex logic</td>
<td>Large nested docs</td>
</tr>
<tr class="odd">
<td>Token-Based</td>
<td>LLM-compatible</td>
<td>May split context</td>
<td>Model-integrated RAG</td>
</tr>
<tr class="even">
<td>Hierarchical</td>
<td>Multi-level retrieval</td>
<td>Needs structure</td>
<td>Textbooks, manuals</td>
</tr>
<tr class="odd">
<td>Content-Aware</td>
<td>Context-sensitive</td>
<td>Metadata-dependent</td>
<td>Web pages, annotated</td>
</tr>
<tr class="even">
<td>Hybrid</td>
<td>Adaptive</td>
<td>Tuning complexity</td>
<td>Mixed content</td>
</tr>
</tbody>
</table>
<hr>
</section>
<section id="advanced-chunking-techniques" class="level2">
<h2 class="anchored" data-anchor-id="advanced-chunking-techniques">Advanced Chunking Techniques</h2>
<p>As RAG systems evolve, so do the demands on chunking strategies. Beyond foundational methods, advanced techniques like dynamic chunking, overlap-aware semantic chunking, and adaptive hierarchical chunking address complex scenarios involving real-time adjustments, multimodal data, or highly variable content. These methods leverage machine learning, query context, and document structure to optimize retrieval and generation, ensuring maximum outreach and performance. Below, we explore these advanced approaches with practical implementations.</p>
<section id="dynamic-chunking" class="level3">
<h3 class="anchored" data-anchor-id="dynamic-chunking">Dynamic Chunking</h3>
<p><strong>Overview</strong>: Dynamic chunking adjusts chunk sizes and boundaries in real-time based on query complexity, content density, or user preferences. Unlike static methods, it uses runtime analysis (e.g., query embeddings or document metadata) to determine optimal splits, making it highly adaptive.</p>
<p><strong>Pros</strong>: - Tailors chunks to specific queries or contexts. - Improves relevance and efficiency dynamically. - Scales with varying content types.</p>
<p><strong>Cons</strong>: - Requires real-time computation, increasing latency. - Complex to implement and tune. - Dependent on robust metadata or query analysis.</p>
<p><strong>Python Code Snippet</strong>:</p>
<div class="sourceCode" id="cb21" style="background: #f1f3f5;"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb21-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> sentence_transformers <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> SentenceTransformer</span>
<span id="cb21-2"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> numpy <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">as</span> np</span>
<span id="cb21-3"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> nltk</span>
<span id="cb21-4">nltk.download(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'punkt'</span>)</span>
<span id="cb21-5"></span>
<span id="cb21-6"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> dynamic_chunking(text, query, base_size<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">200</span>, similarity_threshold<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.8</span>):</span>
<span id="cb21-7">    model <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> SentenceTransformer(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'all-MiniLM-L6-v2'</span>)</span>
<span id="cb21-8">    sentences <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> nltk.sent_tokenize(text)</span>
<span id="cb21-9">    query_embedding <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> model.encode([query])[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>]</span>
<span id="cb21-10">    sentence_embeddings <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> model.encode(sentences)</span>
<span id="cb21-11">    </span>
<span id="cb21-12">    chunks <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> []</span>
<span id="cb21-13">    current_chunk <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> []</span>
<span id="cb21-14">    current_size <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span></span>
<span id="cb21-15">    </span>
<span id="cb21-16">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> i, sentence <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">enumerate</span>(sentences):</span>
<span id="cb21-17">        sentence_similarity <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> np.dot(query_embedding, sentence_embeddings[i]) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/</span> (</span>
<span id="cb21-18">            np.linalg.norm(query_embedding) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span> np.linalg.norm(sentence_embeddings[i])</span>
<span id="cb21-19">        )</span>
<span id="cb21-20">        </span>
<span id="cb21-21">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Adjust chunk size dynamically based on query relevance</span></span>
<span id="cb21-22">        adjusted_size <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> base_size <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> sentence_similarity <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;</span> similarity_threshold <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">else</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">int</span>(base_size <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span> <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">1.5</span>)</span>
<span id="cb21-23">        </span>
<span id="cb21-24">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> current_size <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(sentence) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;=</span> adjusted_size:</span>
<span id="cb21-25">            current_chunk.append(sentence)</span>
<span id="cb21-26">            current_size <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+=</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(sentence)</span>
<span id="cb21-27">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">else</span>:</span>
<span id="cb21-28">            chunks.append(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">' '</span>.join(current_chunk))</span>
<span id="cb21-29">            current_chunk <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [sentence]</span>
<span id="cb21-30">            current_size <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(sentence)</span>
<span id="cb21-31">    </span>
<span id="cb21-32">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> current_chunk:</span>
<span id="cb21-33">        chunks.append(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">' '</span>.join(current_chunk))</span>
<span id="cb21-34">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> chunks</span>
<span id="cb21-35"></span>
<span id="cb21-36"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Example</span></span>
<span id="cb21-37">text <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"RAG systems are powerful tools for AI. They retrieve relevant data quickly. Generation follows retrieval. Chunking impacts performance."</span></span>
<span id="cb21-38">query <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"How does chunking affect RAG?"</span></span>
<span id="cb21-39">chunks <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> dynamic_chunking(text, query, base_size<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">50</span>)</span>
<span id="cb21-40"><span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> i, chunk <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">enumerate</span>(chunks):</span>
<span id="cb21-41">    <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"Chunk </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">: </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>chunk<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">"</span>)</span></code></pre></div>
<p><strong>Output</strong> (varies based on embeddings):</p>
<pre><code>Chunk 1: RAG systems are powerful tools for AI. They retrieve relevant data quickly
Chunk 2: Generation follows retrieval. Chunking impacts performance</code></pre>
<p><strong>Use Case</strong>: Ideal for interactive systems like chatbots or search engines where query context varies widely, requiring on-the-fly adjustments to chunk granularity.</p>
<p><strong>Optimization Tips</strong>: - Cache embeddings for frequently accessed documents to reduce latency. - Use lightweight models (e.g., <code>distilbert</code>) for faster inference. - Incorporate user feedback to refine similarity thresholds.</p>
</section>
<section id="overlap-aware-semantic-chunking" class="level3">
<h3 class="anchored" data-anchor-id="overlap-aware-semantic-chunking">Overlap-Aware Semantic Chunking</h3>
<p><strong>Overview</strong>: This method enhances semantic chunking by introducing controlled overlaps between chunks, guided by meaning similarity. It ensures continuity across semantically related segments while avoiding excessive redundancy.</p>
<p><strong>Pros</strong>: - Balances context preservation and efficiency. - Reduces boundary-related context loss. - Highly relevant retrievals.</p>
<p><strong>Cons</strong>: - Increased storage due to overlaps. - Computationally expensive due to embedding calculations.</p>
<p><strong>Python Code Snippet</strong>:</p>
<div class="sourceCode" id="cb23" style="background: #f1f3f5;"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb23-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> sentence_transformers <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> SentenceTransformer</span>
<span id="cb23-2"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> numpy <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">as</span> np</span>
<span id="cb23-3"></span>
<span id="cb23-4"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> overlap_aware_semantic_chunking(text, overlap_size<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>, similarity_threshold<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.75</span>):</span>
<span id="cb23-5">    model <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> SentenceTransformer(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'all-MiniLM-L6-v2'</span>)</span>
<span id="cb23-6">    sentences <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> text.split(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'. '</span>)</span>
<span id="cb23-7">    embeddings <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> model.encode(sentences)</span>
<span id="cb23-8">    </span>
<span id="cb23-9">    chunks <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> []</span>
<span id="cb23-10">    current_chunk <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [sentences[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>]]</span>
<span id="cb23-11">    overlap_buffer <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> []</span>
<span id="cb23-12">    </span>
<span id="cb23-13">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> i <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>, <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(sentences)):</span>
<span id="cb23-14">        similarity <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> np.dot(embeddings[i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>], embeddings[i]) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/</span> (</span>
<span id="cb23-15">            np.linalg.norm(embeddings[i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>]) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span> np.linalg.norm(embeddings[i])</span>
<span id="cb23-16">        )</span>
<span id="cb23-17">        </span>
<span id="cb23-18">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> similarity <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;</span> similarity_threshold:</span>
<span id="cb23-19">            current_chunk.append(sentences[i])</span>
<span id="cb23-20">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">else</span>:</span>
<span id="cb23-21">            <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Add overlap from previous chunk</span></span>
<span id="cb23-22">            <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> overlap_buffer <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">and</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(overlap_buffer) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;=</span> overlap_size:</span>
<span id="cb23-23">                current_chunk <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> overlap_buffer[<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span>overlap_size:] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> [sentences[i]]</span>
<span id="cb23-24">            <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">else</span>:</span>
<span id="cb23-25">                chunks.append(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'. '</span>.join(current_chunk))</span>
<span id="cb23-26">                current_chunk <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [sentences[i]]</span>
<span id="cb23-27">            overlap_buffer <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> current_chunk.copy()</span>
<span id="cb23-28">    </span>
<span id="cb23-29">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> current_chunk:</span>
<span id="cb23-30">        chunks.append(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'. '</span>.join(current_chunk))</span>
<span id="cb23-31">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> chunks</span>
<span id="cb23-32"></span>
<span id="cb23-33"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Example</span></span>
<span id="cb23-34">text <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"RAG improves AI. It retrieves data. Generation is separate. Chunking is key."</span></span>
<span id="cb23-35">chunks <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> overlap_aware_semantic_chunking(text, overlap_size<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>)</span>
<span id="cb23-36"><span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> i, chunk <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">enumerate</span>(chunks):</span>
<span id="cb23-37">    <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"Chunk </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">: </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>chunk<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">"</span>)</span></code></pre></div>
<p><strong>Output</strong> (varies):</p>
<pre><code>Chunk 1: RAG improves AI. It retrieves data
Chunk 2: It retrieves data. Generation is separate
Chunk 3: Generation is separate. Chunking is key</code></pre>
<p><strong>Use Case</strong>: Best for narratives or technical documents where semantic transitions need smooth handoffs, such as in storytelling AI or detailed manuals.</p>
<p><strong>Optimization Tips</strong>: - Adjust <code>overlap_size</code> based on content density. - Precompute embeddings for static datasets to save time.</p>
</section>
<section id="adaptive-hierarchical-chunking" class="level3">
<h3 class="anchored" data-anchor-id="adaptive-hierarchical-chunking">Adaptive Hierarchical Chunking</h3>
<p><strong>Overview</strong>: Adaptive hierarchical chunking builds a multi-level structure (e.g., sections, paragraphs, sentences) and dynamically selects the retrieval level based on query scope or document complexity. It extends hierarchical chunking with runtime adaptability.</p>
<p><strong>Pros</strong>: - Flexible retrieval granularity. - Adapts to query intent (broad vs.&nbsp;specific). - Rich contextual hierarchy.</p>
<p><strong>Cons</strong>: - Requires structured input or preprocessing. - Complex indexing and retrieval logic.</p>
<p><strong>Python Code Snippet</strong>:</p>
<div class="sourceCode" id="cb25" style="background: #f1f3f5;"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb25-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> sentence_transformers <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> SentenceTransformer</span>
<span id="cb25-2"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> nltk</span>
<span id="cb25-3">nltk.download(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'punkt'</span>)</span>
<span id="cb25-4"></span>
<span id="cb25-5"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> adaptive_hierarchical_chunking(text, query, levels<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>[<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'</span><span class="ch" style="color: #20794D;
background-color: null;
font-style: inherit;">\n\n</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'. '</span>]):</span>
<span id="cb25-6">    model <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> SentenceTransformer(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'all-MiniLM-L6-v2'</span>)</span>
<span id="cb25-7">    query_embedding <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> model.encode([query])[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>]</span>
<span id="cb25-8">    </span>
<span id="cb25-9">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Build hierarchy</span></span>
<span id="cb25-10">    hierarchy <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> []</span>
<span id="cb25-11">    current_level <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [text]</span>
<span id="cb25-12">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> delimiter <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> levels:</span>
<span id="cb25-13">        next_level <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> []</span>
<span id="cb25-14">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> chunk <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> current_level:</span>
<span id="cb25-15">            sub_chunks <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> chunk.split(delimiter)</span>
<span id="cb25-16">            next_level.extend([sub.strip() <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> sub <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> sub_chunks <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> sub.strip()])</span>
<span id="cb25-17">        hierarchy.append(next_level)</span>
<span id="cb25-18">        current_level <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> next_level</span>
<span id="cb25-19">    </span>
<span id="cb25-20">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Select level based on query similarity</span></span>
<span id="cb25-21">    best_level <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span></span>
<span id="cb25-22">    max_similarity <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span></span>
<span id="cb25-23">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> i, level_chunks <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">enumerate</span>(hierarchy):</span>
<span id="cb25-24">        embeddings <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> model.encode(level_chunks)</span>
<span id="cb25-25">        avg_similarity <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> np.mean([np.dot(query_embedding, emb) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/</span> (</span>
<span id="cb25-26">            np.linalg.norm(query_embedding) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span> np.linalg.norm(emb)</span>
<span id="cb25-27">        ) <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> emb <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> embeddings])</span>
<span id="cb25-28">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> avg_similarity <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;</span> max_similarity:</span>
<span id="cb25-29">            max_similarity <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> avg_similarity</span>
<span id="cb25-30">            best_level <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> i</span>
<span id="cb25-31">    </span>
<span id="cb25-32">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> hierarchy[best_level]</span>
<span id="cb25-33"></span>
<span id="cb25-34"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Example</span></span>
<span id="cb25-35">text <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"RAG overview.</span><span class="ch" style="color: #20794D;
background-color: null;
font-style: inherit;">\n\n</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">It retrieves data. Generation follows.</span><span class="ch" style="color: #20794D;
background-color: null;
font-style: inherit;">\n\n</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">Chunking is critical."</span></span>
<span id="cb25-36">query <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"What is chunking in RAG?"</span></span>
<span id="cb25-37">chunks <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> adaptive_hierarchical_chunking(text, query)</span>
<span id="cb25-38"><span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> i, chunk <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">enumerate</span>(chunks):</span>
<span id="cb25-39">    <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"Chunk </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">: </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>chunk<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">"</span>)</span></code></pre></div>
<p><strong>Output</strong> (varies):</p>
<pre><code>Chunk 1: RAG overview
Chunk 2: It retrieves data
Chunk 3: Generation follows
Chunk 4: Chunking is critical</code></pre>
<p><strong>Use Case</strong>: Suited for knowledge bases or academic texts where queries range from high-level summaries to detailed specifics.</p>
<p><strong>Optimization Tips</strong>: - Pre-build hierarchies for static content. - Use caching to store similarity scores for frequent queries.</p>
</section>
<section id="multimodal-chunking" class="level3">
<h3 class="anchored" data-anchor-id="multimodal-chunking">Multimodal Chunking</h3>
<p><strong>Overview</strong>: Multimodal chunking extends chunking to non-text data (e.g., images, tables) alongside text, using tools like OCR or layout analysis to create cohesive multimodal chunks. It’s critical for RAG systems handling diverse inputs.</p>
<p><strong>Pros</strong>: - Supports mixed-media datasets. - Enhances context with visual or tabular data. - Broadens outreach to multimedia applications.</p>
<p><strong>Cons</strong>: - Requires specialized preprocessing (e.g., OCR, image segmentation). - High computational cost.</p>
<p><strong>Python Code Snippet</strong> (Simplified with Text + Image Placeholder)**:</p>
<div class="sourceCode" id="cb27" style="background: #f1f3f5;"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb27-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> PIL <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> Image</span>
<span id="cb27-2"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> pytesseract</span>
<span id="cb27-3"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> nltk</span>
<span id="cb27-4">nltk.download(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'punkt'</span>)</span>
<span id="cb27-5"></span>
<span id="cb27-6"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> multimodal_chunking(text, image_path<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">None</span>, max_text_size<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">200</span>):</span>
<span id="cb27-7">    chunks <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> []</span>
<span id="cb27-8">    </span>
<span id="cb27-9">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Text chunking</span></span>
<span id="cb27-10">    text_chunks <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> []</span>
<span id="cb27-11">    current_chunk <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> []</span>
<span id="cb27-12">    current_size <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span></span>
<span id="cb27-13">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> sentence <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> nltk.sent_tokenize(text):</span>
<span id="cb27-14">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> current_size <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(sentence) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;=</span> max_text_size:</span>
<span id="cb27-15">            current_chunk.append(sentence)</span>
<span id="cb27-16">            current_size <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+=</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(sentence)</span>
<span id="cb27-17">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">else</span>:</span>
<span id="cb27-18">            text_chunks.append(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">' '</span>.join(current_chunk))</span>
<span id="cb27-19">            current_chunk <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [sentence]</span>
<span id="cb27-20">            current_size <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(sentence)</span>
<span id="cb27-21">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> current_chunk:</span>
<span id="cb27-22">        text_chunks.append(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">' '</span>.join(current_chunk))</span>
<span id="cb27-23">    </span>
<span id="cb27-24">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Image chunking (simplified OCR example)</span></span>
<span id="cb27-25">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> image_path:</span>
<span id="cb27-26">        image <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> Image.<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">open</span>(image_path)</span>
<span id="cb27-27">        image_text <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> pytesseract.image_to_string(image)</span>
<span id="cb27-28">        chunks.append({<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'type'</span>: <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'image'</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'content'</span>: image_text})</span>
<span id="cb27-29">    </span>
<span id="cb27-30">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Combine</span></span>
<span id="cb27-31">    chunks.extend({<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'type'</span>: <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'text'</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'content'</span>: chunk} <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> chunk <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> text_chunks)</span>
<span id="cb27-32">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> chunks</span>
<span id="cb27-33"></span>
<span id="cb27-34"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Example</span></span>
<span id="cb27-35">text <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"RAG is a hybrid model. It retrieves and generates data effectively."</span></span>
<span id="cb27-36">image_path <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"example_diagram.png"</span>  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Placeholder</span></span>
<span id="cb27-37">chunks <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> multimodal_chunking(text, image_path)</span>
<span id="cb27-38"><span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> i, chunk <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">enumerate</span>(chunks):</span>
<span id="cb27-39">    <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"Chunk </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;"> (</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>chunk[<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'type'</span>]<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">): </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>chunk[<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'content'</span>]<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">"</span>)</span></code></pre></div>
<p><strong>Output</strong> (hypothetical):</p>
<pre><code>Chunk 1 (image): Diagram of RAG workflow
Chunk 2 (text): RAG is a hybrid model
Chunk 3 (text): It retrieves and generates data effectively</code></pre>
<p><strong>Use Case</strong>: Perfect for multimedia RAG systems, such as educational platforms or technical documentation with diagrams.</p>
<p><strong>Optimization Tips</strong>: - Use efficient OCR libraries (e.g., Tesseract with preprocessing). - Compress images or summarize extracted text to reduce chunk size.</p>
<p>Below is the <strong>comparison table</strong> specifically for the advanced chunking techniques introduced in the previous section: Dynamic Chunking, Overlap-Aware Semantic Chunking, Adaptive Hierarchical Chunking, and Multimodal Chunking. This table is designed to fit into the broader blog structure and provides a concise overview of their pros, cons, and best use cases.</p>
</section>
</section>
<section id="comparison-of-advanced-chunking-techniques" class="level2">
<h2 class="anchored" data-anchor-id="comparison-of-advanced-chunking-techniques">Comparison of Advanced Chunking Techniques</h2>
<table class="caption-top table">
<colgroup>
<col style="width: 18%">
<col style="width: 28%">
<col style="width: 28%">
<col style="width: 23%">
</colgroup>
<thead>
<tr class="header">
<th>Technique</th>
<th>Pros</th>
<th>Cons</th>
<th>Best For</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Dynamic Chunking</strong></td>
<td>- Tailors chunks to query/context<br>- Improves relevance dynamically<br>- Scales with content variety</td>
<td>- Real-time computation increases latency<br>- Complex to implement<br>- Needs robust metadata/query analysis</td>
<td>Interactive systems (e.g., chatbots, search engines) with variable queries</td>
</tr>
<tr class="even">
<td><strong>Overlap-Aware Semantic Chunking</strong></td>
<td>- Balances context and efficiency<br>- Reduces boundary context loss<br>- High retrieval relevance</td>
<td>- Increased storage from overlaps<br>- Computationally expensive<br>- Requires embedding models</td>
<td>Narratives or technical docs needing smooth semantic transitions</td>
</tr>
<tr class="odd">
<td><strong>Adaptive Hierarchical Chunking</strong></td>
<td>- Flexible retrieval granularity<br>- Adapts to query scope<br>- Rich contextual hierarchy</td>
<td>- Requires structured input<br>- Complex indexing/retrieval<br>- Preprocessing overhead</td>
<td>Knowledge bases or academic texts with broad-to-specific queries</td>
</tr>
<tr class="even">
<td><strong>Multimodal Chunking</strong></td>
<td>- Supports mixed-media data<br>- Enhances context with visuals/tables<br>- Broadens multimedia outreach</td>
<td>- Needs specialized preprocessing (e.g., OCR)<br>- High computational cost<br>- Complex integration</td>
<td>Multimedia RAG systems (e.g., educational platforms, technical docs)</td>
</tr>
</tbody>
</table>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>Chunking is a foundational aspect of RAG systems that directly impacts their effectiveness and outreach. From simple fixed-size splits to advanced recursive and hybrid methods, each technique offers unique advantages. By experimenting with these strategies and optimizing based on your use case, you can build a RAG system that delivers precise, efficient, and engaging results. The Python snippets provided here serve as a practical starting point—adapt them, test them, and scale them to suit your needs.</p>


</section>
</section>

 ]]></description>
  <guid>https://ai4nerds.github.io/blog/rag/Different types of Chunking.html</guid>
  <pubDate>Sat, 05 Apr 2025 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Introduction To RAG</title>
  <dc:creator>Ravindra </dc:creator>
  <link>https://ai4nerds.github.io/blog/rag/Introduction to RAG.html</link>
  <description><![CDATA[ 




<section id="what-is-rag" class="level2">
<h2 class="anchored" data-anchor-id="what-is-rag">What is RAG?</h2>
<p>Retrieval-Augmented Generation (RAG) is a framework that enhances Large Language Models (LLMs) by combining them with a retrieval system to access external knowledge during text generation.</p>
<p>Imagine you have a model is trained on just sports data till 2024 year , but you want to get the latest 2025 information also as output</p>
<p>Then RAG will be helpful in inducing that latest/external knowledge to the LLM model</p>
</section>
<section id="core-components" class="level2">
<h2 class="anchored" data-anchor-id="core-components">Core Components</h2>
<section id="retriever" class="level3">
<h3 class="anchored" data-anchor-id="retriever">1. Retriever</h3>
<ul>
<li><p>The retriever is a crucial component of the RAG framework, responsible for fetching relevant information from a knowledge base or document repository. Here are the key elements:</p>
<ul>
<li>Vector Database: A vector database stores embeddings, which are numerical representations of documents or pieces of knowledge. These embeddings are generated by converting text into a high-dimensional space where similar texts are closer together. This allows for efficient similarity searches. The vector database enables quick retrieval of relevant documents based on their embeddings, making it easier to find information that is contextually relevant to a user’s query.</li>
<li>Embedding Model: The embedding model is responsible for converting raw text into vector representations. This process typically involves using techniques like Word2Vec, GloVe, or more advanced models like BERT or Sentence Transformers. The quality of the embeddings directly affects the performance of the retrieval system. A well-trained embedding model captures semantic relationships between words and phrases, allowing for more accurate retrieval of relevant documents.</li>
<li>Similarity Search: Once the query is converted into an embedding, the similarity search component finds documents in the vector database that are most similar to the query embedding. This is often done using techniques like cosine similarity or Euclidean distance. The goal is to retrieve documents that are contextually relevant to the user’s query, ensuring that the subsequent generation step has access to pertinent information.</li>
</ul></li>
</ul>
</section>
<section id="generator" class="level3">
<h3 class="anchored" data-anchor-id="generator">2. Generator</h3>
<ul>
<li><p>The generator is the component that processes the retrieved information and generates responses based on it. Here are the key elements:</p>
<ul>
<li>Language Model: The language model (often a pre-trained transformer model like GPT or BERT) takes the retrieved documents and the original user query as input. It processes this information to generate a coherent and contextually relevant response. The language model leverages its understanding of language and context to produce responses that are not only informative but also natural-sounding.</li>
<li>Context Window: The context window refers to the amount of retrieved content that the language model can use when generating a response. This is important because language models have a maximum input length, and the context window determines how much of the retrieved information can be included. Effective management of the context window is crucial for ensuring that the generated response is relevant and comprehensive.</li>
<li>Prompt Engineering: Prompt engineering involves structuring the input to the language model in a way that maximizes the quality of the generated output. This can include formatting the retrieved information, adding specific instructions, or framing the query in a particular way. Good prompt engineering can significantly enhance the performance of the language model, leading to more accurate and useful responses.</li>
</ul></li>
</ul>
</section>
</section>
<section id="how-rag-works" class="level2">
<h2 class="anchored" data-anchor-id="how-rag-works">How RAG Works</h2>
<p><img src="https://ai4nerds.github.io/blog/rag/images/finalimg.svg" alt="Final Image"></p>
<ol type="1">
<li><strong>Document Processing</strong>
<ul>
<li>Documents are split into chunks</li>
<li>Each chunk is converted into embeddings</li>
<li>Embeddings are stored in a vector database</li>
</ul></li>
<li><strong>Query Processing</strong>
<ul>
<li>User query is received</li>
<li>Query is converted to embedding</li>
<li>Similar documents are retrieved</li>
</ul></li>
<li><strong>Generation</strong>
<ul>
<li>Retrieved documents are combined with the query</li>
<li>LLM generates response using both query and retrieved context</li>
</ul></li>
</ol>
</section>
<section id="benefits-of-rag" class="level2">
<h2 class="anchored" data-anchor-id="benefits-of-rag">Benefits of RAG</h2>
<ul>
<li><strong>Up-to-date Information</strong>: Can access current information not in LLM training</li>
<li><strong>Verifiable Outputs</strong>: Responses can be traced to source documents</li>
<li><strong>Reduced Hallucination</strong>: LLM is grounded in retrieved facts</li>
<li><strong>Domain Adaptation</strong>: Easy to adapt to specific domains</li>
</ul>
</section>
<section id="common-challenges" class="level2">
<h2 class="anchored" data-anchor-id="common-challenges">Common Challenges</h2>
<ol type="1">
<li><strong>Retrieval Quality</strong>
<ul>
<li>Ensuring relevant document retrieval</li>
<li>Handling semantic similarity effectively</li>
<li>Managing context length</li>
</ul></li>
<li><strong>Integration Complexity</strong>
<ul>
<li>Balancing retrieval and generation</li>
<li>Optimizing response time</li>
<li>Managing system resources</li>
</ul></li>
<li><strong>Data Management</strong>
<ul>
<li>Keeping information current</li>
<li>Handling document updates</li>
<li>Maintaining data quality</li>
</ul></li>
</ol>
</section>
<section id="best-practices" class="level2">
<h2 class="anchored" data-anchor-id="best-practices">Best Practices</h2>
<ol type="1">
<li><strong>Document Processing</strong>
<ul>
<li>Use appropriate chunk sizes</li>
<li>Maintain document context</li>
<li>Implement effective cleaning strategies</li>
</ul></li>
<li><strong>Retrieval Strategy</strong>
<ul>
<li>Optimize number of retrieved documents</li>
<li>Implement re-ranking when needed</li>
<li>Use hybrid search approaches</li>
</ul></li>
<li><strong>System Design</strong>
<ul>
<li>Implement caching mechanisms</li>
<li>Monitor system performance</li>
<li>Regular evaluation and tuning</li>
</ul></li>
</ol>
</section>
<section id="use-cases" class="level2">
<h2 class="anchored" data-anchor-id="use-cases">Use Cases</h2>
<ol type="1">
<li><strong>Question Answering</strong>
<ul>
<li>Customer support</li>
<li>Technical documentation</li>
<li>Research assistance</li>
</ul></li>
<li><strong>Content Generation</strong>
<ul>
<li>Report writing</li>
<li>Documentation</li>
<li>Content summarization</li>
</ul></li>
<li><strong>Knowledge Management</strong>
<ul>
<li>Corporate knowledge bases</li>
<li>Educational systems</li>
<li>Research tools</li>
</ul></li>
</ol>
</section>
<section id="evaluation-metrics" class="level2">
<h2 class="anchored" data-anchor-id="evaluation-metrics">Evaluation Metrics</h2>
<ol type="1">
<li><strong>Retrieval Metrics</strong>
<ul>
<li>Precision</li>
<li>Recall</li>
<li>Mean Reciprocal Rank (MRR)</li>
</ul></li>
<li><strong>Generation Metrics</strong>
<ul>
<li>ROUGE scores</li>
<li>BLEU scores</li>
<li>Human evaluation</li>
</ul></li>
</ol>
</section>
<section id="future-directions" class="level2">
<h2 class="anchored" data-anchor-id="future-directions">Future Directions</h2>
<ol type="1">
<li><strong>Advanced Architectures</strong>
<ul>
<li>Multi-step reasoning</li>
<li>Hybrid retrieval methods</li>
<li>Self-improving systems</li>
</ul></li>
<li><strong>Optimization Techniques</strong>
<ul>
<li>Better embedding models</li>
<li>Improved chunking strategies</li>
<li>More efficient retrieval</li>
</ul></li>
</ol>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>RAG represents a significant advancement in AI systems, combining the power of LLMs with the ability to access and utilize external knowledge. As the technology continues to evolve, it promises to deliver more accurate, reliable, and useful AI applications.</p>


</section>

 ]]></description>
  <guid>https://ai4nerds.github.io/blog/rag/Introduction to RAG.html</guid>
  <pubDate>Thu, 03 Apr 2025 00:00:00 GMT</pubDate>
</item>
</channel>
</rss>
